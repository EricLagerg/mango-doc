// Create a man page from a Go package's source file's documentation.
//
// Mango generates section 1 or section 3 man pages, if the Go source package is
//or is not main, respectively. Information is extracted automatically from the
//package's comments and AST, with few exceptions.
//
// If the package is main, the default name of the man page is the name of the
//file that contains the main function. The options section is generated from
//use of the flag package and an optional comment above the main function, a
//line consisting solely of:
//	//Usage: %name %flags EXTRA-OPTIONS
//Mango ignores the "%name" and "%flags" (or "%flag") part is optional but make
//the intent clear to those unfamiliar with mango's directives.
//
// If the package is not main, the default name of the man page is the name of
//the package. It produces one man page per package, in the style of godoc.
//
// In either case, the version is taken from a const named Version, that if not
//present and unspecified on the command line, defaults to today's date. The
//short description of the NAME section is the first paragraph in the package
//comments. The DESCRIPTION section is the remamining paragraphs. If you have
//ALLCAPS words on their own line with no punctuation, with the line above and
//below each empty or containing only whitespace, it will create a new section
//(all such "user" sections are between the OPTIONS and BUGS sections). The BUGS
//section is generated by go/doc.PackageDocs.Bugs. All comments are scanned for
//text such as nroff(1) and this is used to
//generate the SEE ALSO section. Try to avoid examples of functions that take
//a single, one-character argument in comments.
//
// All input from comments is escaped. This means that, while you cannot add
//your own troff formatting, you can neither add your own troff formatting
//accidentally. The generated formatting is minimial, but all attempts are made
//to format each word as best as can be determined statically.
package main

import (
	"flag"
	"os"
	"path"
	"fmt"
	"strings"
	"go/parser"
	"go/ast"
	"go/doc"
)

var (
	import_path = flag.String("import", "",
		"Specify import path")
	version = flag.String("version", "",
		"Specify version")
	manual = flag.String("manual", "",
		"Specify the manual: see man-pages(7)")
	package_name = flag.String("package", "",
		"Select package to use if there are multiple packages in a directory")
)


func stderr(s interface{}) {
	fmt.Fprintln(os.Stderr, s)
}

func fatal(msg interface{}) {
	stderr(msg)
	os.Exit(2)
}

func invalid_flag(s, nm string, flag *string) {
	if *flag != "" {
		fatal("The " + nm + " flag does not apply to section " + s + " pages.")
	}
}

func lspkgs(dir string, pkgs map[string]*ast.Package) {
	stderr(dir + " contains the following packages:")
	for k := range pkgs {
		stderr("\t" + k)
	}
	stderr("Don't know how to handle a directory with multiple packages")
	fatal("Specify one of the above with -package")
}

func usage(err interface{}) {
	stderr(err)
	stderr("mango [flags] [package-directory|package-files]")
	flag.PrintDefaults()
	os.Exit(1)
}

var suff = strings.HasSuffix
var pref = strings.HasPrefix

func filter(fi *os.FileInfo) bool {
	notdir := !fi.IsDirectory()
	n := fi.Name
	gofile := suff(n, ".go") && !suff(n, "_test.go")
	return notdir && gofile
}

func clean(pwd, p string) string {
	if !path.IsAbs(p) {
		p = path.Clean(path.Join(pwd, p))
	}
	return path.Clean(p)
}

//Usage: %name %flags [package-directory|package-files]
func main() {
	flag.Parse()

	pwd, err := os.Getwd()
	if err != nil {
		fatal(err)
	}

	var pkg *ast.Package
	var pkgs map[string]*ast.Package

	//Select and parse files
	dir := pwd
	var files []string
	if flag.NArg() == 1 {
		//one arg we assume is a directory name
		dir = clean(pwd, flag.Arg(0))
		//but it could be a package contained in one .go file
		if suff(dir, ".go") {
			files = []string{dir}
		}
	} else if flag.NArg() > 1 {
		//more than one args we assume is multiple files so we can do
		//mango -import $TARG $GOFILES
		//in make files
		files = flag.Args()
		for i, file := range files {
			files[i] = clean(pwd, file)
		}
	}
	//parse package(s)
	if len(files) > 0 {
		pkgs, err = parser.ParseFiles(files, parser.ParseComments)
	} else {
		pkgs, err = parser.ParseDir(dir, filter, parser.ParseComments)
	}
	if err != nil {
		fatal("Could not parse " + dir + "\n" + err.String())
	}

	//Check for a documentation package
	var xdoc string
	if d, ok := pkgs["documentation"]; ok {
		xdoc = doc.NewPackageDoc(d, "").Doc
		pkgs["documentation"] = nil, false
	}

	//Select package
	switch len(pkgs) {
	case 0:
		fatal("No packages found at " + dir)
	case 1:
		// what we want
	default:
		if *package_name != "" {
			var ok bool
			pkg, ok = pkgs[*package_name]
			if !ok {
				lspkgs(dir, pkgs)
			}
		} else {
			name := path.Base(dir)
			if p, ok := pkgs[name]; ok {
				pkg = p
			} else {
				lspkgs(dir, pkgs)
			}
		}
	}
	if pkg == nil {
		//hack because we don't know or care what the package is
		for _, v := range pkgs {
			pkg = v
		}
	}

	//Build and dump docs
	docs := doc.NewPackageDoc(pkg, "")
	//hack around there being a documentation package, part 2
	if xdoc != "" {
		docs.Doc = xdoc
	}
	m := NewManPage(pkg, docs)

	if pkg.Name == "main" {
		invalid_flag("1", "import", import_path)
		doCommand(m)
	} else {
		doPackage(m)
	}

	m.nl()
	os.Stdout.Write(m.Bytes())
}
