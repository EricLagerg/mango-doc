// Create a man page from a Go package's source file's documentation.
//
// Mango generates section 1 or section 3 man pages, if the Go source package is
//or is not main, respectively. Information is extracted automatically from the
//package's comments and AST, with few exceptions.
//
// If the package is main, the default name of the man page is the name of the
//file that contains the main function. The options section is generated from
//use of the flag package and an optional comment above the main function, a
//line consisting solely of:
//	//Usage: %name %flags EXTRA-OPTIONS
//Mango ignores the "%name" and "%flags" (or "%flag") part is optional but make
//the intent clear to those unfamiliar with mango's directives.
//
// If the package is not main, the default name of the man page is the name of
//the package. It produces one man page per package, in the style of godoc.
//
// In either case, the version is taken from a const named Version, that if not
//present and unspecified on the command line, defaults to today's date. The
//short description of the NAME section is the first paragraph in the package
//comments. The DESCRIPTION section is the remamining paragraphs. If you have
//ALLCAPS words on their own line with no punctuation, with the line above and
//below each empty or containing only whitespace, it will create a new section
//(all such "user" sections are between the OPTIONS and BUGS sections). The BUGS
//section is generated by go/doc/PackageDocs.Bugs. All comments are scanned for
//text in the form word(n) where n is a valid man section and this is used to
//generate the SEE ALSO section. Try to avoid examples of functions that take
//a single, one-character argument in comments.
//
// All input from comments is escaped. This means that, while you cannot add
//your own troff formatting, you can neither add your own troff formatting
//accidentally. The generated formatting is minimial, but all attempts are made
//to format each word as best as can be determined statically.
package main

import (
	"flag"
	"os"
	"path"
	"fmt"
	"strings"
	"go/parser"
	"go/ast"
	"go/doc"
)

//See man-pages(7)
var (
	import_path = flag.String("import", "",
		"Specify import path")
	version = flag.String("version", "",
		"Specify version")
	manual = flag.String("manual", "",
		"Specify the manual: see man-pages(7)")
	package_name = flag.String("package", "",
		"Select package to use if there are multiple packages in a directory")
)


func stderr(s interface{}) {
	fmt.Fprintln(os.Stderr, s)
}

func fatal(msg interface{}) {
	stderr(msg)
	os.Exit(2)
}

func invalid_flag(s, nm string, flag *string) {
	if *flag != "" {
		fatal("The " + nm + " flag does not apply to section " + s + " pages.")
	}
}

func lspkgs(dir string, pkgs map[string]*ast.Package) {
	stderr(dir + " contains the following packages:")
	for k := range pkgs {
		stderr("\t" + k)
	}
	stderr("Don't know how to handle a directory with multiple packages")
	fatal("Specify one of the above with -package")
}

func usage(err interface{}) {
	stderr(err)
	//print usage shit
	os.Exit(1)
}

var suff = strings.HasSuffix
var pref = strings.HasPrefix

func filter(fi *os.FileInfo) bool {
	notdir := !fi.IsDirectory()
	n := fi.Name
	gofile := suff(n, ".go") && !suff(n, "_test.go")
	return notdir && gofile
}

//Usage: %name %flags [package-directory]
func main() {
	flag.Parse()

	pwd, err := os.Getwd()
	if err != nil {
		fatal(err)
	}

	dir := pwd
	if flag.NArg() == 1 {
		dir = flag.Arg(0)
		if !path.IsAbs(dir) {
			dir = path.Join(pwd, dir)
		}
	}

	var pkg *ast.Package

	pkgs, err := parser.ParseDir(dir, filter, parser.ParseComments)
	if err != nil {
		fatal("Could not parse package at " + dir)
	}
	var xdoc string
	if d, ok := pkgs["documentation"]; ok {
		xdoc = doc.NewPackageDoc(d, "").Doc
		pkgs["documentation"] = nil, false
	}
	switch len(pkgs) {
	case 0:
		fatal("No packages found at " + dir)
	case 1:
		// what we want
	default:
		if *package_name != "" {
			var ok bool
			pkg, ok = pkgs[*package_name]
			if !ok {
				lspkgs(dir, pkgs)
			}
		} else {
			name := path.Base(dir)
			if p, ok := pkgs[name]; ok {
				pkg = p
				break
			} else {
				lspkgs(dir, pkgs)
			}
		}
	}
	if pkg == nil {
		//hack because we don't know or care what the package is
		for _, v := range pkgs {
			pkg = v
		}
	}

	docs := doc.NewPackageDoc(pkg, "")
	//hack around there being a documentation package, part 2
	if xdoc != "" {
		docs.Doc = xdoc
	}
	m := NewManPage(pkg, docs)
	if pkg.Name == "main" {
		invalid_flag("1", "import", import_path)
		doCommand(m)
	} else {
		doPackage(m)
	}
	m.nl()

	os.Stdout.Write(m.Bytes())
}
