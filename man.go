package main

import (
	"bytes"
	"strings"
	"fmt"
	"time"
	"go/ast"
	"go/doc"
	"go/token"
	"container/vector"
	"sort"
)

type M struct {
	*F
	name, version, sec string
	descr              []byte
	sections           []*section
	refs               []string
	pkg                *ast.Package
	docs               *doc.PackageDoc
}

func NewManPage(pkg *ast.Package, docs *doc.PackageDoc) *M {
	//extract information that will be present regardless of man section
	ver := grep_version(pkg)

	//break up the package document, extract a short description
	pas := paragraphs(docs.Doc)
	var d []byte
	if len(pas) > 0 {
		sents := sentences(pas[0])
		d = sents[0]
		//if the first paragraph is one sentence, only use it in description;
		//otherwise we leave it where it is to repeat.
		if len(sents) == 1 {
			pas = pas[1:]
		}
	}
	m := &M{
		Formatter(),
		"",
		ver,
		"",
		d,
		sections(pas),
		nil,
		pkg,
		docs,
	}
	m.WriteString(".\\\"    Automatically generated by mango(1)")
	return m
}
func lit(x interface{}) []byte {
	if b, ok := x.(*ast.BasicLit); ok {
		v := b.Value
		switch b.Kind {
		case token.CHAR, token.STRING:
			//need to copy so sentences doesn't muss it up
			nv := make([]byte, len(v)-2)
			copy(nv, v[1:len(v)-1])
			v = nv
		}
		return v
	}
	return nil
}

func grep_version(pkg *ast.Package) string {
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			if g, ok := decl.(*ast.GenDecl); ok {
				if g.Tok == token.CONST {
					for _, s := range g.Specs {
						if v, ok := s.(*ast.ValueSpec); ok {
							for i, n := range v.Names {
								if n.Name == "Version" {
									t := v.Values[i]
									if b, ok := t.(*ast.BasicLit); ok {
										return string(lit(b))
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return ""
}

func flatten(docs *doc.PackageDoc) <-chan string {
	out := make(chan string)
	var sub func(interface{})
	sub = func(x interface{}) {
		switch t := x.(type) {
		case []*doc.ValueDoc:
			for _, v := range t {
				out <- v.Doc
			}
		case []*doc.FuncDoc:
			for _, v := range t {
				out <- v.Doc
			}
		case []*doc.TypeDoc:
			for _, v := range t {
				out <- v.Doc
				sub(v.Consts)
				sub(v.Vars)
				sub(v.Factories)
				sub(v.Methods)
			}
		}
	}
	go func() {
		out <- docs.Doc
		sub(docs.Consts)
		sub(docs.Types)
		sub(docs.Vars)
		sub(docs.Funcs)
		close(out)
	}()
	return out
}

var refrx = RX(SP + rrx)

func (m *M) find_refs() {
	var acc vector.StringVector
	seen := map[string]bool{}
	seen[m.name+"("+m.sec+")"] = true //don't want recursive references
	for str := range flatten(m.docs) {
		for _, idx := range refrx.FindAllStringIndex(str, -1) {
			sub := strings.TrimSpace(str[idx[0]:idx[1]])
			switch sub[len(sub)-2] { //check the part in the ()
			case '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
				'n', 'o', 'l', 'x', 'p':
				//okay, even though most of these are unlikely
				//and some deprecated
			default:
				continue
			}
			if !seen[sub] {
				seen[sub] = true
				acc.Push(sub)
			}
		}
	}
	sort.Sort(&acc)
	m.refs = []string(acc)
}

func (m *M) do_header(kind string) {
	tm := time.LocalTime().Format("2006-01-02")
	version := m.version
	if version == "" {
		version = tm
	}
	m.WriteString(fmt.Sprintf("\n.TH \"%s\" %s \"%s\" \"version %s\" \"%s\"",
		m.name,
		m.sec,
		tm,
		version,
		kind,
	))
}

func (m *M) do_name() {
	m.section("NAME")
	m.WriteString(m.name)
	s := bytes.TrimSpace(m.descr)
	if len(s) > 0 {
		m.WriteString(" \\- ")
		m.Write(s) //first sentence
	}
}

func (m *M) do_description() {
	if len(m.sections) > 0 && len(m.sections[0].paras) > 0 {
		m.section("DESCRIPTION")
		m.paras(m.sections[0].paras)
		m.sections = m.sections[1:]
	}
}

func (m *M) user_sections(sx ...string) {
	ns := make([]*section, len(m.sections))
	n := 0
	for _, rsc := range sx {
		for _, sc := range m.sections {
			if sc.name == rsc {
				m.section(sc.name)
				m.paras(sc.paras)
			} else {
				ns[n] = sc
				n++
			}
		}
	}
	m.sections = ns[:n]
}

func (m *M) remaining_user_sections() {
	for _, sec := range m.sections {
		m.section(sec.name)
		m.paras(sec.paras)
	}
}

func (m *M) do_bugs() {
	bs := m.docs.Bugs
	if len(bs) > 0 {
		m.section("BUGS")
		m.text(bytes.TrimSpace([]byte(bs[0])))
		for _, b := range bs[1:] {
			m.PP()
			m.text(bytes.TrimSpace([]byte(b)))
		}
	}
}

func (m *M) _seealso1(s string) {
	m.WriteString(".BR ")
	piv := strings.Index(s, "(")
	m.Write(escape([]byte(s[:piv])))
	m.WriteByte(' ')
	m.WriteString(s[piv:])
}

func (m *M) do_see_also() {
	if len(m.refs) > 0 {
		m.section("SEE ALSO")
		last := len(m.refs) - 1
		for _, s := range m.refs[:last] {
			m._seealso1(s)
			m.WriteString(",\n")
		}
		m._seealso1(m.refs[last])
	}
}
